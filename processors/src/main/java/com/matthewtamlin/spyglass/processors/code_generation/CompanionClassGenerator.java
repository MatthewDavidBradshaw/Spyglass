package com.matthewtamlin.spyglass.processors.code_generation;

import com.matthewtamlin.spyglass.processors.annotation_utils.UseAnnotationUtil;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.util.HashSet;
import java.util.Set;

import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.VariableElement;

import static com.matthewtamlin.java_utilities.checkers.NullChecker.checkNotNull;
import static com.matthewtamlin.spyglass.processors.annotation_utils.CallHandlerAnnotationUtil.getCallHandlerAnnotation;
import static com.matthewtamlin.spyglass.processors.annotation_utils.DefaultAnnotationUtil.getDefaultAnnotation;
import static com.matthewtamlin.spyglass.processors.annotation_utils.ValueHandlerAnnotationUtil.getValueHandlerAnnotation;
import static com.matthewtamlin.spyglass.processors.code_generation.CallerComponentGenerator.buildGetDefaultValueSpecFor;
import static com.matthewtamlin.spyglass.processors.code_generation.CallerComponentGenerator.buildGetValueSpecFor;
import static com.matthewtamlin.spyglass.processors.code_generation.CallerComponentGenerator.buildShouldCallMethodSpecFor;
import static com.matthewtamlin.spyglass.processors.code_generation.CallerComponentGenerator.buildValueIsAvailableSpecFor;
import static com.matthewtamlin.spyglass.processors.code_generation.InvocationLiteralGenerator.buildInvocationLiteralFor;
import static javax.lang.model.element.Modifier.PUBLIC;

public class CompanionClassGenerator {
	private final ClassName targetClass;

	public static CompanionClassGenerator forTarget(final String packageName, final String className) {
		checkNotNull(packageName, "Argument \'packageName\' cannot be null.");
		checkNotNull(packageName, "Argument \'className\' cannot be null.");

		return new CompanionClassGenerator(ClassName.get(packageName, className));
	}

	public JavaFile generateCompanionFromElements(final Set<ExecutableElement> methods) {
		final Set<TypeSpec> callerSpecs = generateCallerSpecs(methods);

		return null; //TODO
	}

	private CompanionClassGenerator(final ClassName targetClass) {
		this.targetClass = checkNotNull(targetClass, "Argument \'targetClass\' cannot be null.");
	}

	private Set<TypeSpec> generateCallerSpecs(final Set<ExecutableElement> methods) {
		final Set<TypeSpec> callerSpecs = new HashSet<>();

		for (final ExecutableElement e : methods) {
			if (getCallHandlerAnnotation(e) != null) {
				callerSpecs.add(buildCallerForCallHandlerCase(e));

			} else if (getValueHandlerAnnotation(e) != null) {
				callerSpecs.add(
						getDefaultAnnotation(e) != null ?
								buildCallerForValueHandlerWithDefaultCase(e) :
								builderCallerForValueHandlerWithoutDefaultCase(e)
				);
			} else {
				throw new IllegalArgumentException("Argument \'e\' has neither a value handler " +
						"annotation nor a call handler annotation.");
			}
		}

		return callerSpecs;
	}

	private TypeSpec buildCallerForCallHandlerCase(final ExecutableElement e) {
		/* General anonymous caller structure

		new Caller {
			public void callMethod(T target, Context context, TypedArray attrs) {
				if (shouldCallMethod(attrs) {
					target.someMethod(use annotation values);
				}
			}

			public void shouldCallMethod(TypedArray attrs) {
				// Variable implementation, generated by CallerComponentGenerator class
			}
		}
		 */

		final MethodSpec shouldCallMethod = buildShouldCallMethodSpecFor(getCallHandlerAnnotation(e));

		final MethodSpec callMethod = getCallMethodPartialSpec()
				.addCode(CodeBlock
						.builder()
						.addStatement("if ($N(attrs))", shouldCallMethod)
						.addStatement("$L.$L", "target", buildInvocationLiteralFor(e))
						.endControlFlow()
						.build())
				.build();

		return getCallerPartialSpec()
				.addMethod(callMethod)
				.addMethod(shouldCallMethod)
				.build();
	}

	private TypeSpec builderCallerForValueHandlerWithoutDefaultCase(final ExecutableElement e) {
		/* General caller structure without default

		new Caller {
			public void callMethod(T target, Context context, TypedArray attrs) {
				if (valueIsAvailable(attrs) {
					V value = getValue(attrs);
					target.someMethod(use annotation values);
				}
			}

			public void valueIsAvailable(TypedArray attrs) {
				// Variable implementation, generated by CallerComponentGenerator class
			}

			public V getValue(TypedArray attrs) {

			}
		}

		 */

		final MethodSpec valueIsAvailable = buildValueIsAvailableSpecFor(getValueHandlerAnnotation(e));

		final TypeName nonUseParamType = getTypeNameOfNonUseParameter(e);

		final MethodSpec getValue = buildGetValueSpecFor(getValueHandlerAnnotation(e));

		final MethodSpec callMethod = getCallMethodPartialSpec()
				.addCode(CodeBlock
						.builder()
						.addStatement("if ($N(attrs))", valueIsAvailable)
						.addStatement("$T value = ($T) $N(attrs)", nonUseParamType, nonUseParamType, getValue)
						.addStatement("$L.$L", "target", buildInvocationLiteralFor(e, "value"))
						.endControlFlow()
						.build())
				.build();

		return getCallerPartialSpec()
				.addMethod(callMethod)
				.addMethod(valueIsAvailable)
				.addMethod(getValue)
				.build();
	}

	private TypeSpec buildCallerForValueHandlerWithDefaultCase(final ExecutableElement e) {
		/* General caller structure with default

		new Caller {
			public void callMethod(T target, Context context, TypedArray attrs) {
				if (valueIsAvailable(attrs) {
					final V value = getValue(attrs);
					target.someMethod('value' and use annotation literals);
				} else {
					final V value = getDefault(attrs);
					target.someMethod('value' and use annotation literals);
				}
			}

			public void valueIsAvailable(TypedArray attrs) {
				// Variable implementation, generated by CallerComponentGenerator class
			}

			public V getValue(TypedArray attrs) {

			}

			public V getDefault(Context context, TypedArray attrs) {

			}
		}

		 */

		final MethodSpec valueIsAvailable = buildValueIsAvailableSpecFor(getValueHandlerAnnotation(e));

		final TypeName nonUseParamType = getTypeNameOfNonUseParameter(e);

		final MethodSpec getValue = buildGetValueSpecFor(getValueHandlerAnnotation(e));
		final MethodSpec getDefault = buildGetDefaultValueSpecFor(getDefaultAnnotation(e));

		final MethodSpec callMethod = getCallMethodPartialSpec()
				.addCode(CodeBlock
						.builder()
						.addStatement("if ($N(attrs))", valueIsAvailable)
						.addStatement("$T value = ($T) $N(attrs)", nonUseParamType, nonUseParamType, getValue)
						.addStatement("$L.$L", "target", buildInvocationLiteralFor(e, "value"))
						.nextControlFlow("else")
						.addStatement("$T value = ($T) $N(attrs, context)",
								nonUseParamType,
								nonUseParamType,
								getDefault)
						.addStatement("$L.$L", "target", buildInvocationLiteralFor(e, "value"))
						.build())
				.build();

		return getCallerPartialSpec()
				.addMethod(callMethod)
				.addMethod(valueIsAvailable)
				.addMethod(getValue)
				.addMethod(getDefault)
				.build();
	}

	private TypeSpec.Builder getCallerPartialSpec() {
		final ClassName genericCaller = ClassName.get(CallerDef.PACKAGE, CallerDef.INTERFACE_NAME);
		final TypeName specificCaller = ParameterizedTypeName.get(genericCaller, targetClass);

		return TypeSpec
				.anonymousClassBuilder("")
				.addSuperinterface(specificCaller);
	}

	private MethodSpec.Builder getCallMethodPartialSpec() {
		return MethodSpec
				.methodBuilder(CallerDef.METHOD_NAME)
				.returns(void.class)
				.addModifiers(PUBLIC)
				.addParameter(targetClass, "target")
				.addParameter(AndroidClassNames.CONTEXT, "context")
				.addParameter(AndroidClassNames.TYPED_ARRAY, "attrs");
	}

	private TypeName getTypeNameOfNonUseParameter(final ExecutableElement e) {
		for (final VariableElement parameter : e.getParameters()) {
			if (!UseAnnotationUtil.hasUseAnnotation(parameter)) {
				return ClassName.get(parameter.asType());
			}
		}

		throw new RuntimeException("No non-use argument found.");
	}
}